# -*- coding: utf-8 -*-
"""WeightedEditDistance-DP-NLP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18mlrvOkQSauwiss-iMeNmG6TRsrPe51Y
"""

def hammingDistance(x, y):
    ''' Return Hamming distance between x and y '''
    assert len(x) == len(y)
    nmm = 0
    for i in range(0, len(x)):
        if x[i] != y[i]:
            nmm += 1
    return nmm

hammingDistance('brown', 'blown')

def boundEditDistance(x, y):
    ''' Return loose lower and upper bounds on the edit distance
        between x and y in O(|x| + |y|) time. '''
    if x == y: return 0, 0
    if len(x) == 0: return len(y), len(y)
    if len(y) == 0: return len(x), len(x)
    diff = abs(len(x) - len(y))
    lower = diff
    if lower == 0 and x != y:
        lower = 1
    minlen = min(len(x), len(y))
    upper = hammingDistance(x[:minlen], y[:minlen]) + diff
    return lower, upper

boundEditDistance('brown', 'blown')

boundEditDistance('create', 'creator')

boundEditDistance('create', 'creation')

boundEditDistance('GCGTATGCACGC', 'GCTATGCCACGC')

boundEditDistance('the longest', 'longest day')

from numpy import zeros

def edDistDp(x, y):
    """ Calculate edit distance between sequences x and y using
        matrix dynamic programming.  Return distance. """
    D = zeros((len(x)+1, len(y)+1), dtype=int)
    D[0, 1:] = range(1, len(y)+1)
    D[1:, 0] = range(1, len(x)+1)
    for i in range(1, len(x)+1):
        for j in range(1, len(y)+1):
            delt = 1 if x[i-1] != y[j-1] else 0
            D[i, j] = min(D[i-1, j-1]+delt, D[i-1, j]+1, D[i, j-1]+1)
    return D[len(x), len(y)]

edDistDp('Shakespeare', 'shake spear')

edDistDp('the longest', 'longest day')
